import kotlin.Boolean;
import kotlin.String;
import kotlin.collections.List;

-- ==========================================
-- 1. SESSIONS TABLE
-- ==========================================
CREATE TABLE Session (
    id TEXT NOT NULL PRIMARY KEY,
    title TEXT NOT NULL,
    pinned INTEGER AS Boolean DEFAULT 0 NOT NULL,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    session_type TEXT NOT NULL,

    -- Chat Options
    seed INTEGER,
    temperature REAL,
    top_k INTEGER,
    top_p REAL,
    min_p REAL,
    stop TEXT,
    num_ctx INTEGER,
    num_predict INTEGER,
    format TEXT
);

CREATE INDEX idx_session_updated_at ON Session(updated_at DESC);

CREATE VIEW SessionView AS
SELECT
    id,
    title,
    pinned,
    created_at AS createdAt,
    updated_at AS updatedAt,
    session_type AS sessionType,

    -- Chat Options
    seed,
    temperature,
    top_k AS topK,
    top_p AS topP,
    min_p AS minP,
    stop,
    num_ctx AS numCtx,
    num_predict AS numPredict,
    format

FROM Session;

-- ==========================================
-- 2. MESSAGES TABLE
-- ==========================================
CREATE TABLE Message (
    id TEXT NOT NULL PRIMARY KEY,
    session_id TEXT NOT NULL,
    model_name TEXT NOT NULL,
    role TEXT NOT NULL,
    content TEXT,
    thinking TEXT,
    images TEXT AS List<String>,
    tool_calls TEXT,
    logprobs TEXT,
    created_at INTEGER NOT NULL,
    is_done INTEGER AS Boolean DEFAULT 0 NOT NULL,
    done_reason TEXT,
    errored INTEGER AS Boolean DEFAULT 0 NOT NULL,
    error_message TEXT,
    total_duration INTEGER,
    load_duration INTEGER,
    prompt_eval_count INTEGER,
    prompt_eval_duration INTEGER,
    eval_count INTEGER,
    eval_duration INTEGER,

    FOREIGN KEY (session_id) REFERENCES Session(id) ON DELETE CASCADE
);

CREATE INDEX idx_message_session_id ON Message(session_id);
CREATE INDEX idx_message_created_at ON Message(created_at ASC);


CREATE VIEW MessageView AS
SELECT
    id,
    session_id AS sessionId,
    model_name AS modelName,
    role,
    content,
    thinking,
    images,
    tool_calls AS toolCalls,
    logprobs,
    created_at AS createdAt,
    is_done AS isDone,
    done_reason AS doneReason,
    total_duration AS totalDuration,
    load_duration AS loadDuration,
    prompt_eval_count AS promptEvalCount,
    prompt_eval_duration AS promptEvalDuration,
    eval_count AS evalCount,
    eval_duration AS evalDuration
FROM Message;


-- ==========================================
-- QUERIES: SESSIONS
-- ==========================================

insertSession:
INSERT INTO Session (id, title, pinned, created_at, updated_at, session_type)
VALUES (?, ?, ?, ?, ?, ?);

getSessionById:
SELECT *
FROM SessionView
WHERE id = :id;

getSessionsPaged:
SELECT *
FROM SessionView
ORDER BY pinned DESC, updatedAt DESC
LIMIT :limit OFFSET :offset;

getAllSessions:
SELECT *
FROM SessionView
ORDER BY pinned DESC, updatedAt DESC;

updateSessionTimestamp:
UPDATE Session
SET updated_at = :updatedAt
WHERE id = :id;

deleteSession:
DELETE FROM Session WHERE id = :id;

sessionExists:
SELECT EXISTS(SELECT 1 FROM Session WHERE id = :id);

clearSession:
DELETE FROM Message
WHERE session_id = :sessionId;

-- Returns the total number of sessions (required for Paging3 to calculate total pages)
countSessions:
SELECT count(*) FROM Session;


updateSession:
UPDATE Session
SET
    title = :title,
    pinned = :pinned,
    seed = :seed,
    temperature = :temperature,
    top_k = :topK,
    top_p = :topP,
    min_p = :minP,
    stop = :stop,
    num_ctx = :numCtx,
    num_predict = :numPredict,
    format = :format,
    updated_at = :updatedAt
WHERE id = :id;

-- Rename a session
updateSessionTitle:
UPDATE Session
SET title = :title, updated_at = :updatedAt
WHERE id = :id;


-- Toggle pin status
toggleSessionPin:
UPDATE Session
SET
    pinned = CASE WHEN pinned = 1 THEN 0 ELSE 1 END,
    updated_at = :updatedAt
WHERE id = :id;

-- Search sessions
searchSessionsPaged:
SELECT *
FROM SessionView
WHERE title LIKE '%' || :query || '%'
ORDER BY pinned DESC, updatedAt DESC
LIMIT :limit OFFSET :offset;

countSearchSessions:
SELECT count(*)
FROM Session
WHERE title LIKE '%' || :query || '%';

getLatestSession:
SELECT *
FROM Session
ORDER BY updated_at DESC
LIMIT 1;

getLastUsedSession:
SELECT sv.*
FROM SessionView sv
JOIN Message m ON m.session_id = sv.id
ORDER BY m.created_at DESC
LIMIT 1;




-- ==========================================
-- QUERIES: MESSAGES
-- ==========================================

insertMessage:
INSERT INTO Message (
    id, session_id, model_name, role, content, thinking,
    images, tool_calls, logprobs, created_at, is_done
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);


getMessageById:
SELECT * FROM MessageView
WHERE id = :id;

appendMessageContent:
UPDATE Message
SET content = coalesce(content, '') || :contentChunk
WHERE id = :id;

appendMessageThinking:
UPDATE Message
SET thinking = coalesce(thinking, '') || :thinkingChunk
WHERE id = :id;

finalizeMessage:
UPDATE Message
SET is_done = 1,
    done_reason = :doneReason,
    total_duration = :totalDuration,
    load_duration = :loadDuration,
    prompt_eval_count = :promptEvalCount,
    prompt_eval_duration = :promptEvalDuration,
    eval_count = :evalCount,
    eval_duration = :evalDuration
WHERE id = :id;

getMessagesBySessionId:
SELECT * FROM MessageView
WHERE sessionId = :sessionId
ORDER BY createdAt ASC;

getMessagesBySessionIdPaged:
SELECT * FROM MessageView
WHERE sessionId = :sessionId
ORDER BY createdAt ASC
LIMIT :limit OFFSET :offset;

countMessages:
SELECT count(*) FROM Message WHERE session_id = :sessionId;


deleteMessageById:
DELETE FROM Message
WHERE id = :id;


getLastMessage:
SELECT * FROM MessageView
ORDER BY createdAt DESC
LIMIT 1;

getLastMessageOfSessionId:
SELECT * FROM MessageView
WHERE sessionId = :sessionId
ORDER BY createdAt DESC
LIMIT 1;

updateMessageDoneStatus:
UPDATE Message
SET is_done = :isDone,
    done_reason = :doneReason
WHERE id = :id;

updateMessageErrorStatus:
UPDATE Message
SET errored = :errored,
    error_message = :errorMessage,
    is_done = 1,
    done_reason = 'error'
WHERE id = :id;

markAllUnfinishedAssistantMessagesAsError:
UPDATE Message
SET
    errored = 1,
    is_done = 1,
    done_reason = 'error',
    error_message = 'Some error occurred while processing the message.'
WHERE role = 'assistant'
AND is_done = 0;
